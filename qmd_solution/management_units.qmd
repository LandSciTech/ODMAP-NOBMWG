---
title: "Planning_units"
format: html
editor: visual
---

```{r}
# app.R

# Load the shiny library
library(shiny)
library(dplyr) # For data manipulation
library(sf)
# --- Data Definition ---
# LIST OF POTENTIAL MANAGEMENT UNITS
# 1. Bird Conservation Areas in North America
# From this link https://www.birdscanada.org/bird-science/nabci-bird-conservation-regions

# IMPORTANT: Ensure 'bcr_NA.csv' is located at the specified path or in a 'www' folder
# within your Shiny app's directory (e.g., "www/bcr_NA.csv") for portability.
# The following code for BCRs_df is taken directly from your input.
# If 'bcr_NA.csv' is not found or does not contain expected columns, this part might need adjustment.
BCRs_df <- read.csv("./www/bcr_NA.csv", header=TRUE, sep=",") %>%
  dplyr::select(2:3) %>% # Selects the 2nd and 3rd columns as per your instruction
  dplyr::distinct() %>% # Gets unique values
  na.omit() # Removes any NA values

BCRs_df$Unit_Name <- paste0("BCR_", BCRs_df$bcr_label, " (", BCRs_df$bcr_label_name, ")")

# Standardize column names for binding rows
BCRs_df["Management_unit_Type"] <- "Birds Conservation Regions (BCRs)"
BCRs_df <- BCRs_df %>% dplyr::select(Unit_Name, Management_unit_Type) # Keep only relevant columns for binding

# 2. Provinces and Territories in Canada
# The following code for Canada_df is taken directly from your input.
canadian_provinces_territories <- c(
  "Alberta", "British Columbia", "Manitoba", "New Brunswick",
  "Newfoundland and Labrador", "Nova Scotia", "Ontario",
  "Prince Edward Island", "Quebec", "Saskatchewan",
  "Northwest Territories", "Nunavut", "Yukon"
)
Canada_df <- data.frame(Unit_Name = canadian_provinces_territories) %>%
  na.omit() # Removes any NA values (though none expected here)
Canada_df["Management_unit_Type"] <- "Provinces_Territories"

# 3. Ecoregions (from Diverstein 2017. https://ecoregions.appspot.com/)
ecoregions <- sf::st_read("./default_data_sets/Ecoregions2017/Ecoregions2017.shp")%>%
  sf::st_drop_geometry()%>%
  dplyr::select(2)%>%
  dplyr::rename(Unit_Name = ECO_NAME)%>%
  dplyr::distinct() %>% # Gets unique values
  na.omit() # Removes any NA values

ecoregions["Management_unit_Type"] <- "Ecoregions"

#3. Protected Areas Canada_df
PACs_df <- read.csv("./www/cpas_canada.csv", header=TRUE, sep=",") %>%
  dplyr::filter(STATUS== 1)%>%
  dplyr::filter(OWNER_TYPE== 1 | OWNER_TYPE== 2)%>%
   dplyr::filter(PA_OECM_DF == 1)%>%
  dplyr::select(3) %>% # Selects the 2nd and 3rd columns as per your instruction
  dplyr::rename(Unit_Name = NAME_E)%>%
  dplyr::distinct() %>% # Gets unique values
  na.omit() # Removes any NA values
  
# Standardize column names for binding rows
PACs_df["Management_unit_Type"] <- "Protected Ares Canada (PACs)"
PACs_df <- PACs_df %>% dplyr::select(Unit_Name, Management_unit_Type)%>% # Keep only relevant columns for binding
  arrange(Unit_Name)
PACs_df <- PACs_df%>%
filter(!grepl("[A-Za-z].*[0-9]|[0-9].*[A-Za-z]", Unit_Name))

PACs_df2 <- PACs_df[!grepl("^[0-9]+$", PACs_df$Unit_Name), ]
# Combine data frames by rows
# The 'data' data frame now contains both BCRs and Canadian Provinces/Territories
# This 'data' dataframe will only contain 'Unit_Name' and 'Management_unit_Type' columns
# as per your instruction not to change BCRs_df, Canada_df, and data.
data <- dplyr::bind_rows(BCRs_df, Canada_df, ecoregions)



# --- User Interface (UI) ---
ui <- fluidPage(
  # Application title
  titlePanel("Select potential planning and management units covered by model outputs"),

  # Sidebar layout with a sidebar and main panel
  sidebarLayout(
    # Sidebar panel for inputs
    sidebarPanel(
      # Input: Selector for Main Category (Management Unit Type)
      selectInput(
        inputId = "main_item",
        label = "Select Management Unit Type:",
        # Choices are now based on the 'Management_unit_Type' column
        choices = unique(data$Management_unit_Type),
        multiple = TRUE # ALLOW MULTIPLE SELECTIONS FOR MAIN CATEGORY
      ),

      # New: Button to select all main categories
     # actionButton(
      #  inputId = "select_all_main_items",
      #  label = "Select All Main Categories"
    #  ),
      br(), # Add a line break for spacing
       br(), # Add a line break for spacing
       br(), # Add a line break for spacing
       br(), # Add a line break for spacing
       br(), # Add a line break for spacing
       br(), # Add a line break for spacing
       br(), # Add a line break for spacing

      # Input: Selector for Sub Category (Unit Name - dynamically rendered)
      # uiOutput is used because the choices for this input depend on the main_item selection
      uiOutput("sub_item_selector"),
      

      # Button to select all sub-items (re-added as per previous requests)
     # actionButton(
      #  inputId = "select_all_sub_items",
      #  label = "Select All Units"
     # ),
      br(), # Add a line break for spacing
 br(), # Add a line break for spacing
  br(), # Add a line break for spacing
  br(), # Add a line break for spacing
  br(), # Add a line break for spacing
  br(), # Add a line break for spacing
  br(), # Add a line break for spacing
  br(), # Add a line break for spacing
 br(), # Add a line break for spacing
  br(), # Add a line break for spacing
      # Submit button to trigger table update
      actionButton(
        inputId = "submit_selection",
        label = "Submit Selection"
      )
    ),

    # Main panel for displaying outputs
    mainPanel(
      # Output: Data table based on selections
      h3("Selected Data:"),
      tableOutput("report_table"),
      hr(),
      "Sources:",
      br(),
    tags$a(href="https://www.birdscanada.org/bird-science/nabci-bird-conservation-regions", "Birds' Conservation BCRs (BCRs)"),
    br(),
     tags$a(href="https://ecoregions.appspot.com/", "Ecoregions (Dinerstein et al. 2017)")
    )
  )
)

# --- Server Logic ---
server <- function(input, output, session) {

  # Initialize a reactiveVal to store accumulated data for the report table
  # It starts as an empty data frame with the correct column names
  accumulated_report_data <- reactiveVal(
    data.frame(
      Unit_Name = character(0),
      Management_unit_Type = character(0),
      stringsAsFactors = FALSE
    )
  )

  # Reactive expression to filter sub-categories (Unit_Name) based on selected main item (Management_unit_Type)
  # This ensures that when the main_item changes, the available sub_items are updated.
  filtered_sub_categories <- reactive({
    req(input$main_item) # Ensure main_item is selected before proceeding
    # If multiple main items are selected, we need to get unique sub-categories across all selected main items
    data %>%
      filter(Management_unit_Type %in% input$main_item) %>% # Use %in% for multiple main selections
      pull(Unit_Name) %>% # Pulls the 'Unit_Name' column
      unique()
  })

  # Render the dynamic sub-item selector
  output$sub_item_selector <- renderUI({
    # Create a selectInput for the sub-category using the dynamically filtered choices
    selectInput(
      inputId = "sub_item",
      label = "Select Unit Name:", # Updated label
      choices = filtered_sub_categories(),
      multiple = TRUE # Allows multiple sub-items to be selected
    )
  })

  # Observe event for the "Select All Main Categories" button
  observeEvent(input$select_all_main_items, {
    # Update the 'main_item' input to select all available main categories
    updateSelectInput(
      session = session,
      inputId = "main_item",
      selected = unique(data$Management_unit_Type) # Set selected to all unique main categories
    )
  })

  # Observe event for the "Select All Units" button
  observeEvent(input$select_all_sub_items, {
    # Update the 'sub_item' input to select all available sub-categories
    updateSelectInput(
      session = session,
      inputId = "sub_item",
      selected = filtered_sub_categories() # Set selected to all unique sub-categories based on currently selected main items
    )
  })

  # Observe event for the "Submit Selection" button
  observeEvent(input$submit_selection, {
    # Ensure both main_item and sub_item are selected before processing
    req(input$main_item, input$sub_item)

    # Filter the data based on current selections
    new_submission_data <- data %>%
      filter(
        Management_unit_Type %in% input$main_item, # Filter by multiple Management_unit_Type
        Unit_Name %in% input$sub_item # Use %in% for multiple Unit_Name selections
      ) %>%
      # Select only the columns that are present in the 'data' dataframe based on your definition.
      # As per your instruction, 'data' only contains 'Unit_Name' and 'Management_unit_Type'.
     dplyr::select(Management_unit_Type,Unit_Name)

    # Append the new submission data to the accumulated data
    # Use unique() to prevent adding duplicate rows if the same selection is submitted again
    accumulated_report_data(
      unique(
        rbind(accumulated_report_data(), new_submission_data)
      )
    )

    # Clear the main_item selection after submission
    updateSelectInput(
      session = session,
      inputId = "main_item",
      selected = character(0) # Set to an empty character vector to clear all selections
    )

    # Clear the sub_item selection after submission
    updateSelectInput(
      session = session,
      inputId = "sub_item",
      selected = character(0) # Set to an empty character vector to clear all selections
    )
  })

  # Render the report table using the accumulated_report_data reactiveVal
  output$report_table <- renderTable({
    accumulated_report_data() # Display the accumulated filtered data
  })
  
  
}

# --- Run the application ---
shinyApp(ui, server)

```
