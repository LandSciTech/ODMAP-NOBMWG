---
title: "SDMs_Modelling_Packages"
format: html
editor: visual
---

```{r}
library(shiny)
library(DT) # For interactive tables
library(dplyr)
library(htmltools)
library(purrr)
library(shinyjs) # For delayed messages

# ---
# Read the CSV file
data_packages <- tryCatch({
  read.csv("./datasets_solutions/Modelling_SDMs_Packages.csv", stringsAsFactors = FALSE)
}, error = function(e) {
  warning(paste("Could not read CSV file:", e$message))
  data.frame(
    Software = character(0),
    Package = character(0),
    Version = character(0),
    Description = character(0),
    URL = character(0),
    stringsAsFactors = FALSE
  )
})

# Create the clickable "Source" link
if ("URL" %in% colnames(data_packages) && "Package" %in% colnames(data_packages)) {
  data_packages$Source <- paste0("<a href='", data_packages$URL, "' target='_blank'>", data_packages$Package, "</a>")
} else if ("URL" %in% colnames(data_packages) && "Name" %in% colnames(data_packages)) {
  data_packages$Source <- paste0("<a href='", data_packages$URL, "' target='_blank'>", data_packages$Name, "</a>")
} else {
  data_packages$Source <- ""
  warning("Missing 'URL' or 'Package'/'Name' column in 'Modelling_SDMs_Packages.csv'. Source links might not be generated correctly.")
}

# Ensure all necessary columns are present after reading and before selection
data_packages <- data_packages %>%
  dplyr::select(c(Software, Package, Version, Description, Source))

# ---
# Define UI for application
ui <- fluidPage(
  useShinyjs(),

  titlePanel("Firstly, 'Checkbox' the Package, then double click to add the Version, then Submit Selection"),

  sidebarLayout(
    sidebarPanel(
      h4("1. Select from the list"),
      br(),

      h5("1a. If not in the list: add new entry:"),
      textInput("new_Software", "Software"),
      textInput("new_Package", "Package"),
      textInput("new_Version", "Version"),
      textInput("new_Description", "Description"),
      textInput("new_Source", "Source URL"),
      actionButton("add_new_entry", "Add New Entry to List"),
      br(),
      uiOutput("add_entry_message"),
      hr(),
      actionButton("submit_selection", "2. Submit Selection")
    ),
    mainPanel(
      DTOutput("my_table"),
      h4("Packages selected:"),
      DTOutput("selected_data_table")
    )
  ),

  # MODIFIED: JavaScript to pass original row ID
  tags$script(HTML("
    $(document).on('change', '#my_table .row_selector', function() {
      var original_row_id = $(this).data('original-row-id'); // Get the original row ID
      var is_checked = $(this).prop('checked');
      Shiny.setInputValue('my_table_checkbox_clicked', {
        row: original_row_id, // Send the original row ID
        checked: is_checked
      }, {priority: 'event'});
    });
  "))
)

# ---
# Define server logic
server <- function(input, output, session) {

  # Reactive value to store all data (initial + new entries).
  app_data <- reactiveValues(
    full_table = data_packages
  )

  # Reactive value to store the ORIGINAL indices of selected rows
  selected_rows_indices <- reactiveVal(integer(0))

  # Observe event for adding new entry
  observeEvent(input$add_new_entry, {
    req(input$new_Software, input$new_Package, input$new_Version, input$new_Description, input$new_Source)

    if (!grepl("^https?://", input$new_Source)) {
      output$add_entry_message <- renderUI({
        HTML("<p style='color:red;'>Source must be a valid URL (starts with http:// or https://)</p>")
      })
      return()
    }

    new_source_link <- paste0("<a href='", input$new_Source, "' target='_blank'>", input$new_Package, "</a>")

    new_row <- data.frame(
      Software = input$new_Software,
      Package = input$new_Package,
      Version = input$new_Version,
      Description = input$new_Description,
      Source = new_source_link,
      stringsAsFactors = FALSE
    )

    app_data$full_table <- rbind(app_data$full_table, new_row)

    updateTextInput(session, "new_Software", value = "")
    updateTextInput(session, "new_Package", value = "")
    updateTextInput(session, "new_Version", value = "")
    updateTextInput(session, "new_Description", value = "")
    updateTextInput(session, "new_Source", value = "")

    output$add_entry_message <- renderUI({
      HTML("<p style='color:green;'>Entry added successfully!</p>")
    })
    shinyjs::delay(3000, output$add_entry_message <- renderUI(NULL))
  })

  # Render the DataTable with custom checkboxes and editable Version
  output$my_table <- renderDT({
    df <- app_data$full_table
    selected_idx_original <- selected_rows_indices() # These are original indices

    # Add a temporary column for original row numbers (1-based)
    # This ensures we track the actual row in app_data$full_table
    df_with_original_id <- df %>%
      mutate(original_row_id = 1:n())

    df_display <- df_with_original_id %>%
      mutate(
        Checkbox = map_chr(row_number(), ~{
          # Get the original_row_id for the current row in df_display
          original_id_for_this_row <- df_with_original_id$original_row_id[.x]
          checked_attr <- if (original_id_for_this_row %in% selected_idx_original) "checked" else ""
          # Pass the ORIGINAL row ID to JavaScript
          paste0("<input type='checkbox' class='row_selector' data-original-row-id='", original_id_for_this_row, "' ", checked_attr, ">")
        })
      ) %>%
      # Explicitly select columns to maintain order and drop the temporary original_row_id
      dplyr::select(Checkbox, Software, Package, Version, Description, Source)

    datatable(
      df_display,
      editable = list(target = 'cell', columns = 3), # Version column is 0-indexed at 3 in df_display
      escape = FALSE,
      options = list(
        dom = 't',
        paging = FALSE,
        searching = TRUE,
        info = FALSE,
        ordering = FALSE,
        scrollY = "300px",
        scrollX = TRUE,
        scrollCollapse = TRUE,
        columnDefs = list(list(orderable = FALSE, className = 'dt-center', targets = 0))
      ),
      selection = 'none',
      rownames = FALSE
    )
  }, server = TRUE)

  # Listener for custom checkbox clicks
  observeEvent(input$my_table_checkbox_clicked, {
    info <- input$my_table_checkbox_clicked
    # 'row_id' now directly corresponds to the original 1-based index in app_data$full_table
    row_original_id <- as.numeric(info$row)
    is_checked <- info$checked

    current_selected <- selected_rows_indices()

    if (is_checked) {
      if (!row_original_id %in% current_selected) {
        selected_rows_indices(sort(c(current_selected, row_original_id)))
      }
    } else {
      selected_rows_indices(current_selected[current_selected != row_original_id])
    }
  })

  # Observe table cell edits
  observeEvent(input$my_table_cell_edit, {
    info = input$my_table_cell_edit

    # Print current state BEFORE edit attempt
    cat("\n--- CELL EDIT TRIGGERED ---\n")
    cat("app_data$full_table BEFORE edit:\n")
    # print(app_data$full_table) # Uncomment for detailed debug

    # Info from DT
    # info$row is the 1-based row index in the underlying data (app_data$full_table)
    # info$col is the 0-based column index in the DT table (df_display)
    cat("DT Edit Info: Row (original app_data index) =", info$row, ", Col (0-idx DT) =", info$col, ", New Value =", info$value, "\n")

    # Target column "Version" is at 0-based index 2 in app_data$full_table
    # But info$col is from df_display, where Version is at 0-indexed 3.
    # So, we need to convert info$col (from df_display) back to the index in app_data$full_table
    # df_display columns: Checkbox(0), Software(1), Package(2), Version(3), Description(4), Source(5)
    # app_data$full_table columns: Software(0), Package(1), Version(2), Description(3), Source(4)
    # So, DT's info$col = 3 corresponds to app_data$full_table's col = 2 (0-indexed)
    # Or, info$col + 1 is the 1-indexed column in df_display, and we need to map that to app_data$full_table
    # A safer way is to explicitly check the column name, but given the fixed structure:
    # DT's info$col for Version is 3. In app_data$full_table, Version is the 3rd column (index 2).
    # So, if info$col == 3, we update app_data$full_table[, 3] (1-indexed column)
    # The DT package's editable feature for `target = 'cell'` usually gives `info$col`
    # corresponding to the *original* column index if you don't add columns at the beginning.
    # However, since you added 'Checkbox' at the start, `info$col` maps to the displayed DT.
    # Given your `editable = list(target = 'cell', columns = 3)`, info$col will be 3 for Version.
    # This means the 3rd column in `df_display` (0-indexed) is being edited.
    # In `app_data$full_table`, the "Version" column is the 3rd column (1-indexed).
    # So, if info$col is 3, then `info$col` directly translates to the 1-based index `info$col + 1` in `app_data$full_table` if we consider
    # that `app_data$full_table` doesn't have the `Checkbox` column.
    # Let's verify the column index mapping carefully:
    # app_data$full_table: 1=Software, 2=Package, 3=Version, 4=Description, 5=Source
    # df_display: 1=Checkbox, 2=Software, 3=Package, 4=Version, 5=Description, 6=Source
    # If info$col = 3 (0-indexed Version in df_display), then in app_data$full_table it is column 3 (1-indexed).
    # So the current update `app_data$full_table[info$row, info$col + 1]` is actually correct here,
    # assuming info$col is the 0-indexed column from df_display and you're adding 1 to make it R's 1-indexed.
    # Let's confirm with a more robust check:
    target_col_name <- "Version"
    # Find the 1-based index of "Version" in the app_data$full_table
    actual_col_index_in_app_data <- which(colnames(app_data$full_table) == target_col_name)

    # Check if the edited column (info$col, 0-indexed from DT display) maps to the Version column
    # In df_display, Version is the 4th column (0-indexed: 3).
    # This corresponds to the 3rd column (1-indexed: 3) in app_data$full_table.
    if (info$col == 3) { # The 0-indexed column 3 in df_display is 'Version'
      app_data$full_table[info$row, actual_col_index_in_app_data] <- info$value
      showNotification(paste("Version updated for row", info$row, "to", info$value), type = "message", duration = 2)
    } else {
      showNotification(paste("Attempted to edit non-Version column (Col:", info$col, "). Change not saved."), type = "warning", duration = 3)
    }

    # Print state AFTER edit attempt
    cat("app_data$full_table AFTER edit attempt:\n")
    # print(app_data$full_table) # Uncomment for detailed debug
    cat("Value in target cell (", info$row, ",", actual_col_index_in_app_data, ") AFTER edit:", app_data$full_table[info$row, actual_col_index_in_app_data], "\n")
    cat("--- END CELL EDIT ---\n")
  })

  # Reactive value to store selected and newly added rows after submission
  submitted_final_data <- eventReactive(input$submit_selection, {
    selected_idx <- selected_rows_indices() # These are the original 1-based indices

    cat("\n--- SUBMIT SELECTION TRIGGERED ---\n")
    cat("Selected Indices for submission:", paste(selected_idx, collapse = ", "), "\n")

    # Access the latest state of app_data$full_table
    current_table_data <- app_data$full_table
    cat("app_data$full_table AT SUBMISSION (full data):\n")
    # print(current_table_data) # Uncomment for detailed debug

    final_data <- data.frame()
    if (length(selected_idx) > 0) {
      # Use the stored original indices to subset the full table
      final_data <- current_table_data[selected_idx, , drop = FALSE]
    }

    if (nrow(final_data) > 0) {
      cat("Final data to display in output table (Packages selected):\n")
      print(final_data) # <--- THIS PRINT STATEMENT SHOULD NOW SHOW THE DATA
      return(final_data)
    } else {
      cat("No rows selected for submission.\n")
      return(data.frame(
        Software = character(0),
        Package = character(0),
        Version = character(0),
        Description = character(0),
        Source = character(0),
        stringsAsFactors = FALSE
      ))
    }
    cat("--- END SUBMIT SELECTION ---\n")
  })

  # Display the submitted selection in a new DataTable
  output$selected_data_table <- renderDT({
    req(submitted_final_data())

    datatable(
      submitted_final_data(),
      escape = FALSE, # Set to FALSE so 'Source' links are clickable
      options = list(
        dom = 't',
        paging = FALSE,
        ordering = FALSE,
        scrollY = "300px",
        scrollX = TRUE,
        scrollCollapse = TRUE
      ),
      rownames = FALSE
    )
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```
