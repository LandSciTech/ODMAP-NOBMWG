---
title: "Assumptions"
format: html
editor: visual
---

```{r}
# app.R
library(shiny)
library(dplyr) # For data manipulation
library(tibble) # For tribble
library(DT) # For interactive data tables
library(readr) # For reading CSV data

# --- Data Definition (Load from CSV File) ---

# Specify the path to your CSV file.
# Make sure 'your_data.csv' is in the same directory as app.R,
# or provide the full path (e.g., "C:/Users/YourUser/Documents/your_data.csv").
csv_file_path <- "./datasets_solutions/Assumptions.csv" # <--- IMPORTANT: RENAME THIS TO YOUR ACTUAL CSV FILE NAME

# Load the data from the CSV file into a data frame named 'app_data'.
# This part is fine outside the server function, as it's a static data load.
app_data <- read.csv(csv_file_path, stringsAsFactors = FALSE)

# You can add a check here to ensure the file was loaded correctly and has expected columns.
expected_cols <- c("Category", "Assumptions", "Assumption_Description",
                   "Violation_of_Assumptions", "Potential_Effects",
                   "Potential_Solutions", "Comment")
if (!all(expected_cols %in% names(app_data))) {
  stop(paste("The CSV file must contain all the following columns:", paste(expected_cols, collapse = ", ")))
}


# --- Shiny UI Definition ---

ui <- fluidPage(
  titlePanel("Category, Assumptions, Potential Effects, and Potential Solutions Selector"),

  sidebarLayout(
    sidebarPanel(
      # Category selection with add new option
      uiOutput("category_ui"),
      div(
        style = "display: flex; align-items: center;",
        textInput("new_category_input", "Add New Category:", value = ""),
        actionButton("add_category_btn", "Add Category", style = "margin-left: 5px; margin-top: 25px;")
      ),
      hr(), # Horizontal line for separation

      # Assumptions selection with add new option
      uiOutput("assumptions_ui"),
      div(
        style = "display: flex; align-items: center;",
        textInput("new_assumptions_input", "Add New Assumption:", value = ""),
        actionButton("add_assumptions_btn", "Add Assumption", style = "margin-left: 5px; margin-top: 25px;")
      ),
      hr(),

      # Potential Effects selection with add new option
      uiOutput("potential_effects_ui"),
      div(
        style = "display: flex; align-items: center;",
        textInput("new_potential_effects_input", "Add New Effect:", value = ""),
        actionButton("add_potential_effects_btn", "Add Effect", style = "margin-left: 5px; margin-top: 25px;")
      ),
      hr(),

      # Potential Solutions selection with add new option
      uiOutput("potential_solutions_ui"),
      div(
        style = "display: flex; align-items: center;",
        textInput("new_potential_solutions_input", "Add New Solution:", value = ""),
        actionButton("add_potential_solutions_btn", "Add Solution", style = "margin-left: 5px; margin-top: 25px;")
      ),
      hr(),

      # Add a text input for comments (this will be the app's comment input)
      textInput(
        inputId = "comment_input",
        label = "Add a comment for this selection:",
        value = ""
      ),

      actionButton("submit_btn", "Submit Selection") # Submit button
    ),

    mainPanel(
      h3("Current Selection:"),
      tableOutput("selection_table"),

      # The submitted selections section is at the bottom
      h3("Submitted Selections:"),
      DTOutput("submitted_data_table_ui") # Use DTOutput for interactive tables
    )
  )
)

# --- Shiny Server Logic ---

server <- function(input, output, session) {

  # Reactive values for the core data and user-added items
  current_item_hierarchy <- reactiveVal(tibble())
  current_category_descriptions <- reactiveVal(tibble())

  # Reactive values to store ONLY user-added items for each dropdown.
  # These are separate from items loaded from app_data.
  user_added_categories <- reactiveVal(character(0))
  user_added_assumptions <- reactiveVal(character(0))
  user_added_potential_effects <- reactiveVal(character(0))
  user_added_potential_solutions <- reactiveVal(character(0))


  # Create a reactive value to store all submitted data
  submitted_data <- reactiveVal(
    tibble(
      Category = character(),
      Assumptions = character(),
      `Assumption Description` = character(),
      `Violation of Assumptions` = character(),
      `Potential Effects` = character(),
      `Potential Solutions` = character(),
      Comment = character()
    )
  )

  # --- Initial Data Population (Runs once at app start-up) ---
  observeEvent(session, {
    current_item_hierarchy(
      app_data %>%
        select(Category, Assumptions, Potential_Effects, Potential_Solutions) %>%
        distinct()
    )

    current_category_descriptions(
      app_data %>%
        select(Category, Assumption_Description, Violation_of_Assumptions) %>%
        distinct(Category, .keep_all = TRUE)
    )
  }, once = TRUE)


  # Reactive: All available categories (from data + user additions)
  all_categories_choices <- reactive({
    data_categories <- unique(current_item_hierarchy()$Category)
    sort(unique(c(data_categories, user_added_categories())))
  })

  # Render the Category dropdown dynamically
  output$category_ui <- renderUI({
    choices_category <- all_categories_choices()
    selectizeInput(
      inputId = "category_select",
      label = "Select Category:",
      choices = choices_category,
      selected = if (length(choices_category) > 0) choices_category[1] else NULL,
      multiple = FALSE
    )
  })

  # Observe the "Add Category" button click
  observeEvent(input$add_category_btn, {
    new_cat <- trimws(input$new_category_input)
    if (new_cat != "" && !(new_cat %in% all_categories_choices())) {
      user_added_categories(c(user_added_categories(), new_cat)) # Add to user-added list
      updateTextInput(session, "new_category_input", value = "")
      updateSelectizeInput(session, "category_select", choices = all_categories_choices(), selected = new_cat)

      current_cd <- current_category_descriptions()
      new_row_desc <- tibble(
        Category = new_cat,
        Assumption_Description = paste("Description for", new_cat),
        Violation_of_Assumptions = paste("Violations for", new_cat)
      )
      current_category_descriptions(bind_rows(current_cd, new_row_desc))
    }
  })

  # Reactive: Filtered assumptions based on selected category AND user-added assumptions
  filtered_assumptions <- reactive({
    req(input$category_select)
    # Start with assumptions from the current_item_hierarchy for the selected category
    data_assumptions <- current_item_hierarchy() %>%
      filter(Category == input$category_select) %>%
      pull(Assumptions) %>%
      unique()

    # Combine with user-added assumptions
    combined_assumptions <- unique(c(data_assumptions, user_added_assumptions()))

    # Return only those user-added assumptions that are *not* already in the data_assumptions
    # This logic assumes user-added assumptions can appear in any category,
    # if they are specific to a category, that's a more complex data structure.
    # For now, we'll just present all relevant data assumptions PLUS all user-added ones.
    # If the user-added assumption should only appear if explicitly linked to a category,
    # the data structure needs to change.
    
    # Simplest approach: show data-driven items + all user-added items (if they fit the hierarchy later during submit)
    # The more accurate way for cascading is to only add user_added_assumptions if they are relevant to the selected category.
    # For now, we'll ensure they are sorted and unique.
    sort(combined_assumptions)
  })


  # Render the Assumptions dropdown dynamically
  output$assumptions_ui <- renderUI({
    choices_assumptions <- filtered_assumptions()
    selectizeInput(
      inputId = "assumptions_select",
      label = "Select Assumptions:",
      choices = choices_assumptions,
      selected = if (length(choices_assumptions) > 0) choices_assumptions[1] else NULL,
      multiple = FALSE
    )
  })

  # Observe the "Add Assumption" button click
  observeEvent(input$add_assumptions_btn, {
    new_assum <- trimws(input$new_assumptions_input)
    # Ensure it's not already in the overall list (data + user-added)
    if (new_assum != "" && !(new_assum %in% filtered_assumptions())) {
      user_added_assumptions(sort(c(user_added_assumptions(), new_assum)))
      updateTextInput(session, "new_assumptions_input", value = "")
      # Update the choices of the selectize input with the newly filtered list
      updateSelectizeInput(session, "assumptions_select", choices = filtered_assumptions(), selected = new_assum)
    }
  })


  # Reactive: Filtered potential effects based on category AND assumptions selection, plus user-added
  filtered_potential_effects <- reactive({
    req(input$category_select, input$assumptions_select)
    if (nrow(current_item_hierarchy()) == 0) return(character(0))

    data_effects <- current_item_hierarchy() %>%
      filter(Category == input$category_select,
             Assumptions == input$assumptions_select) %>%
      pull(Potential_Effects) %>%
      unique()

    combined_effects <- unique(c(data_effects, user_added_potential_effects()))
    sort(combined_effects)
  })

  # Render the Potential_effects dropdown dynamically
  output$potential_effects_ui <- renderUI({
    choices_potential_effects <- filtered_potential_effects()
    selectizeInput(
      inputId = "potential_effects_select",
      label = "Select Potential Effects:",
      choices = choices_potential_effects,
      selected = if (length(choices_potential_effects) > 0) choices_potential_effects[1] else NULL,
      multiple = FALSE
    )
  })

  # Observe the "Add Effect" button click
  observeEvent(input$add_potential_effects_btn, {
    new_effect <- trimws(input$new_potential_effects_input)
    if (new_effect != "" && !(new_effect %in% filtered_potential_effects())) {
      user_added_potential_effects(sort(c(user_added_potential_effects(), new_effect)))
      updateTextInput(session, "new_potential_effects_input", value = "")
      updateSelectizeInput(session, "potential_effects_select", choices = filtered_potential_effects(), selected = new_effect)
    }
  })

  # Reactive: Filtered potential solutions based on all three preceding selections, plus user-added
  filtered_potential_solutions <- reactive({
    req(input$category_select, input$assumptions_select, input$potential_effects_select)
    if (nrow(current_item_hierarchy()) == 0) return(character(0))

    data_solutions <- current_item_hierarchy() %>%
      filter(Category == input$category_select,
             Assumptions == input$assumptions_select,
             Potential_Effects == input$potential_effects_select) %>%
      pull(Potential_Solutions) %>%
      unique()

    combined_solutions <- unique(c(data_solutions, user_added_potential_solutions()))
    sort(combined_solutions)
  })

  # Render the Potential_solutions dropdown dynamically
  output$potential_solutions_ui <- renderUI({
    choices_potential_solutions <- filtered_potential_solutions()
    selectizeInput(
      inputId = "potential_solutions_select",
      label = "Select Potential Solutions:",
      choices = choices_potential_solutions,
      selected = if (length(choices_potential_solutions) > 0) choices_potential_solutions[1] else NULL,
      multiple = FALSE
    )
  })

  # Observe the "Add Solution" button click
  observeEvent(input$add_potential_solutions_btn, {
    new_sol <- trimws(input$new_potential_solutions_input)
    if (new_sol != "" && !(new_sol %in% filtered_potential_solutions())) {
      user_added_potential_solutions(sort(c(user_added_potential_solutions(), new_sol)))
      updateTextInput(session, "new_potential_solutions_input", value = "")
      updateSelectizeInput(session, "potential_solutions_select", choices = filtered_potential_solutions(), selected = new_sol)
    }
  })

  # Output the currently selected items
  output$selection_table <- renderTable({
    req(input$category_select, input$assumptions_select, input$potential_effects_select, input$potential_solutions_select)

    category_info <- current_category_descriptions() %>%
      filter(Category == input$category_select)

    tibble(
      `Category` = input$category_select,
      `Assumptions` = input$assumptions_select,
      `Assumption Description` = if(nrow(category_info) > 0) category_info$Assumption_Description else "N/A",
      `Violation of Assumptions` = if(nrow(category_info) > 0) category_info$Violation_of_Assumptions else "N/A",
      `Potential Effects` = input$potential_effects_select,
      `Potential Solutions` = input$potential_solutions_select,
      `Comment` = input$comment_input
    )
  }, striped = TRUE, bordered = TRUE, na = "â€”")


  # Observe the submit button click
  observeEvent(input$submit_btn, {
    req(input$category_select, input$assumptions_select, input$potential_effects_select, input$potential_solutions_select)

    category_info <- current_category_descriptions() %>%
      filter(Category == input$category_select)

    new_data <- tibble(
      Category = input$category_select,
      Assumptions = input$assumptions_select,
      `Assumption Description` = if(nrow(category_info) > 0) category_info$Assumption_Description else "N/A",
      `Violation of Assumptions` = if(nrow(category_info) > 0) category_info$Violation_of_Assumptions else "N/A",
      `Potential Effects` = input$potential_effects_select,
      `Potential Solutions` = input$potential_solutions_select,
      `Comment` = input$comment_input,
    )

    current_data <- submitted_data()

    if (input$comment_input != "" || all(new_data[, c("Category", "Assumptions", "Potential Effects", "Potential Solutions")] != "N/A")) {
      if (nrow(current_data) == 0) {
        updated_data <- new_data
      } else {
        new_unique_data <- anti_join(new_data, current_data, by = names(new_data))
        updated_data <- bind_rows(current_data, new_unique_data)
      }
      submitted_data(updated_data)

      # Reset dropdowns and comment box after submission
      # Use the reactive choices for updating, and set selected to NULL for cascading effect
      updateSelectizeInput(session, "category_select", selected = all_categories_choices()[1])
      updateSelectizeInput(session, "assumptions_select", selected = NULL)
      updateSelectizeInput(session, "potential_effects_select", selected = NULL)
      updateSelectizeInput(session, "potential_solutions_select", selected = NULL)
      updateTextInput(session, "comment_input", value = "")
    } else {
      showNotification("Please add a comment before submitting, or ensure all selections are valid.", type = "warning", duration = 3)
    }
  })

  # Render the accumulated submitted data as a DT table with buttons for removal
  output$submitted_data_table_ui <- renderDT({
    current_data <- submitted_data()
    if (nrow(current_data) == 0) {
      return(datatable(tibble(`No selections submitted yet.` = "Click 'Submit Selection' to add to this table."), options = list(dom = 't')))
    }

    data_with_buttons <- current_data %>%
      mutate(Action = paste0(
        '<button class="btn btn-danger btn-sm remove-btn" data-row-id="',
        1:nrow(current_data),
        '">Remove</button>'
      ))

    datatable(
      data_with_buttons,
      escape = FALSE,
      selection = "none",
      options = list(
        dom = 't',
        paging = FALSE,
        ordering = FALSE,
        columnDefs = list(
          list(width = '80px', targets = ncol(data_with_buttons) - 1)
        )
      ),
      callback = JS(
        "table.on('click', '.remove-btn', function() {",
        "  var row_index = $(this).data('row-id');",
        "  Shiny.setInputValue('remove_row_click', row_index, {priority: 'event'});",
        "});"
      )
    )
  })

  # New observeEvent to handle the remove button click from the DT table's callback
  observeEvent(input$remove_row_click, {
    row_to_remove <- as.integer(input$remove_row_click)
    current_data <- submitted_data()
    if (!is.na(row_to_remove) && row_to_remove > 0 && row_to_remove <= nrow(current_data)) {
      updated_data <- current_data[-row_to_remove, ]
      submitted_data(updated_data)
    }
  })
}

shinyApp(ui, server)
```
