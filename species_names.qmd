---
title: "Species_names"
format: html
editor: visual
---

```{r}
# app.R

# Load the shiny library
library(shiny)
library(magrittr)
library(dplyr)
library(tidyr) # For distinct on multiple columns (though dplyr::distinct does it too)

# --- Define the User Interface (UI) ---
ui <- fluidPage(
  # Application title
  titlePanel("Select Species Name(s) within Class"),
  
  br(),
 # tags$h4("Mammals List (Sample Data)"),

  # Sidebar layout with dropdowns for selection
  sidebarLayout(
    sidebarPanel(
      # Dropdown for Class (Birds or Mammals)
      selectInput(
        inputId = "selected_Class",
        label = "Select Class:",
        choices = c("Birds", "Mammals"),
        selected = "Birds" # Default selection
      ),
      # Dropdown for sub-items (species names), dynamically populated
      selectInput(
        inputId = "selected_sub_items",
        label = "Select Species Name(s):",
        choices = NULL, # Choices will be set by the server
        multiple = TRUE # Allow multiple selections
      ),
      hr(), # Horizontal rule for separation
      actionButton("save_selection_btn", "Save Current Selection", class = "btn-primary"),
      br(),br(), # Add some spacing
      actionButton("clear_saved_btn", "Clear All Saved Selections", class = "btn-danger")
    ),

    # Main panel to display the output
    mainPanel(
      h3("Currently Selected Species (before saving):"),
      tableOutput("output_current_selection"), # Display current selection
      hr(),
      h3("All Saved Species Selections:"),
      tableOutput("output_saved_species"), # Display all saved selections
      hr(),
      "Sources:",
      br(),
    tags$a(href="https://open.canada.ca/data/en/dataset/0a2dfadd-57eb-4d64-a56d-ff53c431aaaa", "Birds' List from this source")
    )
  )
)

# --- Define the Server Logic ---
server <- function(input, output, session) {

  # Reactive expression to load and prepare all data
  all_species_data <- reactive({
    # Bird Data
    url_birds <- "https://data-donnees.az.ec.gc.ca/api/file?path=%2Fspecies%2Fassess%2Fcanadian-breeding-bird-census-plots%2FCanadianBreedingBirdCensusSpecies_EspecesDeRecensementDesOiseauxNicheursDuCanada.csv"
    birds_data <- tryCatch({
      read.csv(url_birds, header = TRUE, check.names = FALSE, stringsAsFactors = FALSE) %>%
        dplyr::select(COMNAME, TAXON, CODE) %>%
        dplyr::rename(Common_name = COMNAME,
                      Scientific_name = TAXON,
                      Code = CODE) %>%
        dplyr::distinct() %>%
        dplyr::mutate(Class = "Birds") %>% # Add a Class column
        dplyr::arrange(Common_name) %>%
        dplyr::filter(duplicated(Common_name) == F)
    }, error = function(e) {
      # Handle potential errors with URL or data loading
      warning("Could not load bird data: ", e$message)
      data.frame(Common_name = character(), Scientific_name = character(), Code = character(), Class = character())
    })


    # Mammal Data (Sample Data)
    
    mammals_data <- read.csv("./datasets_solutions/Mammals_Canada.csv", header=T)

    # Combine data frames
    bind_rows(birds_data, mammals_data)
  })

  # Reactive value to store all saved selections
  # Initialize with an empty data frame with the correct columns
  saved_selections <- reactiveVal(
    data.frame(
      Common_name = character(0),
      Scientific_name = character(0),
      Code = character(0),
      Class = character(0),
      stringsAsFactors = FALSE
    )
  )

  # Observe changes in the 'selected_Class' dropdown
  observeEvent(input$selected_Class, {
    req(all_species_data()) # Ensure data is loaded

    # Filter the data based on the selected Class for the sub-item dropdown choices
    filtered_data_for_dropdown <- all_species_data() %>%
      filter(Class == input$selected_Class)

    # Get unique common names from the filtered data
    sub_item_choices <- unique(filtered_data_for_dropdown$Common_name)

    # Update the 'selected_sub_items' dropdown
    updateSelectInput(
      session,
      inputId = "selected_sub_items",
      choices = sub_item_choices,
      selected = NULL # Clear previous selections in the sub-item dropdown when Class changes
    )
    
  })

  # Reactive expression for the currently selected rows (before saving)
  current_selection_df <- reactive({
    # Only proceed if a Class and at least one sub-item are selected
    req(input$selected_Class, input$selected_sub_items)

    all_species_data() %>%
      filter(Class == input$selected_Class,
             Common_name %in% input$selected_sub_items)
  })

  # Render the table for currently selected species
  output$output_current_selection <- renderTable({
    current_selection_df()
  })

  # Observe the "Save Selection" button click
  observeEvent(input$save_selection_btn, {
    current_rows_to_save <- current_selection_df()

    if (nrow(current_rows_to_save) > 0) {
      # Get existing saved selections
      existing_selections <- saved_selections()

      # Combine existing and new selections
      combined_selections <- bind_rows(existing_selections, current_rows_to_save)

      # Remove duplicates based on all relevant columns to ensure uniqueness
      # Using distinct on all identifying columns (Common_name, Scientific_name, Code, Class)
      unique_selections <- combined_selections %>%
        dplyr::distinct(Common_name, Scientific_name, Code, Class, .keep_all = TRUE) %>%
        dplyr::arrange(Class, Common_name) # Order for consistent display

      # Update the reactive value
      saved_selections(unique_selections)

      # --- Clear dropdowns after saving ---
      # Reset Class dropdown to its default ("Birds")
      updateSelectInput(
        session,
        inputId = "selected_Class",
        selected = "Birds"
      )
      # Reset sub-items dropdown. The previous update to selected_Class will trigger
      # the observeEvent for selected_Class, which in turn populates this dropdown
      # and sets selected = NULL. So explicitly setting it here again is redundant
      # if you're resetting the main category. However, if you wanted to clear it
      # without changing the main category, you would use:
      # updateSelectInput(session, inputId = "selected_sub_items", selected = NULL)
      # For now, relying on the 'selected_Class' observeEvent to handle it.


      showNotification("Selection saved successfully!", type = "message", duration = 2)

    } else {
      showNotification("Please select species to save.", type = "warning", duration = 3)
    }
  })

  # Observe the "Clear All Saved" button click
  observeEvent(input$clear_saved_btn, {
    # Reset saved_selections to an empty data frame
    saved_selections(
      data.frame(
        Common_name = character(0),
        Scientific_name = character(0),
        Code = character(0),
        Class = character(0),
        stringsAsFactors = FALSE
      )
    )
    showNotification("All saved selections cleared.", type = "message", duration = 2)
  })

  # Render the table for all saved species
  output$output_saved_species <- renderTable({
    # Display the saved selections. If empty, show a message.
    if (nrow(saved_selections()) == 0) {
      return(data.frame(Message = "No species saved yet. Select some and click 'Save Current Selection'."))
    } else {
      return(saved_selections())
    }
  })
}

# --- Run the application ---
shinyApp(ui = ui, server = server)
```
