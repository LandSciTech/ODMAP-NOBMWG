---
title: "Biodiversity_source"
format: html
editor: visual
---

```{r}
library(shiny)
library(DT) # For interactive tables
library(dplyr)
library(htmltools)
library(purrr)

# Create data frame
df <- data.frame(
  Data_type = c("Presence-only", "Presence/Absence", "Point occurrence", "Counts", "Richness", "Integration of aeral and point data"),
  Data_source = rep("Add the data source here (website, repo, etc.)", 6),
  Comments = rep("Add your comments/explain here", 6),
  stringsAsFactors = FALSE
)

# Define UI for application
ui <- fluidPage(
  titlePanel("Select and Edit Data Types"),

  sidebarLayout(
    sidebarPanel(
      h4("1. Select from the list"),
      br(),
      h5("1a. If not in the list: add new entry:"),
      textInput("new_datatype", "Data_type"),
      textInput("new_source", "Data_source"),
      textInput("new_comments", "Comments"),
      actionButton("add_new_entry", "Add New Entry to List"),
      hr(), # Horizontal rule to separate sections
      actionButton("submit_selection", "2. Submit Selection")
    ),
    mainPanel(
      DTOutput("my_table"),
      h4("Selected and Submitted Covariates:"),
      DTOutput("selected_data_table")
    )
  )
)

# Define server logic
server <- function(input, output, session) {

  # Reactive value to store the main data, including initial data and new entries
  # This data will also be updated upon in-table edits
  current_data <- reactiveVal(df)

  # Observe event for adding new entry
  observeEvent(input$add_new_entry, {
    req(input$new_datatype, input$new_source, input$new_comments)

    new_row <- data.frame(
      Data_type = input$new_datatype,
      Data_source = input$new_source,
      Comments = input$new_comments,
      stringsAsFactors = FALSE
    )

    current_data(rbind(current_data(), new_row))

    # Clear input fields after adding
    updateTextInput(session, "new_datatype", value = "")
    updateTextInput(session, "new_source", value = "")
    updateTextInput(session, "new_comments", value = "")
  })

  # Render the DataTable with editable columns
  output$my_table <- renderDT({
    datatable(
      current_data(), # Use the reactive value for the data
      editable = list(target = 'cell', disable = list(columns = 0)), # Make cells editable, disable editing first column (Data_type)
      extensions = 'Select', # Enable row selection
      options = list(
        dom = 't', # Only show the table, hide search/pagination
        paging = FALSE,
        ordering = FALSE,
        select = list(style = 'multi', selector = 'td:first-child'), # Enable multi-row selection with checkbox in first column
        scrollY = "300px",
        scrollX = TRUE,
        scrollCollapse = TRUE
      ),
      selection = 'none', # Disable default DT row selection to use custom checkboxes
      callback = JS(
        "table.on('click', 'td:first-child', function(){", # Listen for clicks on the first column (checkbox)
        "  var row_index = table.cell(this).index().row;",
        "  var row_data = table.row(row_index).data();",
        "  var checkbox = $(this).find('input[type=\"checkbox\"]');",
        "  if (checkbox.prop('checked')) {",
        "    table.row(row_index).deselect();", # Deselect if checkbox is checked
        "  } else {",
        "    table.row(row_index).select();", # Select if checkbox is unchecked
        "  }",
        "});",
        "table.on('select', function(e, dt, type, indexes){", # When a row is selected programmatically
        "  if (type === 'row') {",
        "    var checkbox = dt.cells(indexes, 0).nodes().to$().find('input[type=\"checkbox\"]');",
        "    checkbox.prop('checked', true);",
        "  }",
        "});",
        "table.on('deselect', function(e, dt, type, indexes){", # When a row is deselected programmatically
        "  if (type === 'row') {",
        "    var checkbox = dt.cells(indexes, 0).nodes().to$().find('input[type=\"checkbox\"]');",
        "    checkbox.prop('checked', false);",
        "  }",
        "});",
        "return table.column(0).nodes().to$().each(function(i, td) {", # Add checkbox to the first column
        "  $(td).html('<input type=\"checkbox\">');",
        "});"
      )
    )
  }, server = FALSE) # server = FALSE for client-side processing, which is easier for checkbox integration

  # Observe table edits
  observeEvent(input$my_table_cell_edit, {
    info <- input$my_table_cell_edit
    str(info) # For debugging: print the edit information

    # Get the current data
    data_to_edit <- current_data()

    # Apply the edit
    data_to_edit[info$row, info$col] <- info$value

    # Update the reactive value with the modified data
    current_data(data_to_edit)
  })

  # Reactive value to store selected and newly added rows after submission
  submitted_final_data <- eventReactive(input$submit_selection, {
    # Get the row indices of selected rows from DT
    selected_indices <- input$my_table_rows_selected

    if (length(selected_indices) > 0) {
      # Return the selected rows from the *current_data* (which includes edits and new entries)
      return(current_data()[selected_indices, ])
    } else {
      # Return an empty data frame with correct column names if no rows are selected
      return(data.frame(
        Data_type = character(0),
        Data_source = character(0),
        Comments = character(0),
        stringsAsFactors = FALSE
      ))
    }
  })

  # Display the submitted selection and new entries in a new DataTable
  output$selected_data_table <- renderDT({
    # Ensure the table is rendered only when submitted_final_data has data
    req(submitted_final_data())

    datatable(
      submitted_final_data(),
      options = list(
        dom = 't', # Only show the table
        paging = FALSE,
        ordering = FALSE,
        scrollY = "300px",
        scrollX = TRUE,
        scrollCollapse = TRUE
      ),
      rownames = FALSE # Do not show row names in the output table
    )
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```
